### BE Unit Test Prompt
 
As a backend Java developer working on maintenance project, your main task is to generate unit test cases for the existing Java codebase. The testing framework of choice is Mockito and JUnit, and the tests must adhere to the following structure and guidelines:
 
Your tests must achieve 100% coverage, ensuring every line of code, branch, and condition is tested
Thoroughly analyze the provided Java code to gain a clear understanding of its functionality. Identify any ambiguities, missing information such as constants, type definitions, or external APIs, and pinpoint areas that require clarification. Before proceeding with the tests, ask questions or seek clarification to ensure a complete and accurate understanding of the code.
Use JUnit and Mockito as the unit testing framework to validate the code’s functionality. Each test case should adhere to unit testing principles, ensuring that it focuses on a single piece of functionality at a time. To enhance reliability and speed, simulate external dependencies using mock objects, allowing tests to run in isolation without relying on actual implementations
Follow the Arrange-Act-Assert (AAA) pattern to maintain clarity and structure in test cases. In the Arrange phase, set up the necessary preconditions for the test. The Act phase involves performing the specific action being tested. Finally, in the Assert phase, verify that the results match the expected outcome. Adhering to this structure ensures well-organized and effective test cases.
Design tests to focus on small, isolated functions, keeping them straightforward and easy to maintain. Ensure that test cases cover both the happy path, where the code behaves as expected, and failure modes, which validate error handling and unexpected scenarios. Additionally, consider edge cases to improve the robustness of the application and prevent potential issues in less common situations.
Make use of annotations such as @BeforeEach, @BeforeAll, @AfterEach, @CsvSource and @ParameterizedTest, to organise your tests
When testing components, always interact with them through public methods or properties rather than modifying their internal state directly. Private methods should remain untested, as the focus should be on verifying functionality through the component’s public interface while maintaining encapsulation. Keep tests simple by avoiding unnecessary complexity like loops or conditional logic. Leverage on available java libraries to catch potential bugs early, ensuring code reliability. Additionally, handle asynchronous operations correctly by using proper async/await syntax to prevent timing-related issues in tests.
When writing tests, ensure that early return scenarios are properly covered. For instance, in Java, a method might return early based on a condition, such as: if (condition == null) {  return;  }  
Write test cases where condition is null to verify the early exit logic, and also test scenarios where condition is valid to ensure the remaining code executes correctly. For private methods that include early returns, test them indirectly through the public methods that invoke them. Additionally, handle null or undefined values by testing cases where optional fields or objects are missing. For example, in Java, a condition like: if (object != null && object.getProperty() != null) { /* do something */ },  should be tested with cases where object is null, where object exists but getProperty() returns null, and where both are valid to ensure proper execution. When designing test cases, incorporate edge cases such as empty collections, empty strings, or unexpected non-boolean values that might affect conditions. Also, ensure coverage for deeply nested properties to maintain robustness. Finally, for comprehensive test coverage, combine different input variations to simulate real-world scenarios and extreme cases. Utilize tools like JaCoCo to measure code coverage and ensure all branches and execution paths are thoroughly tested.
The goal is to develop a comprehensive suite of unit tests that thoroughly validates the provided Java code, ensuring high code quality and coverage.
 
Java code:
<paste java code here>