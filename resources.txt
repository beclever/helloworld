非常好的问题！针对MongoDB设计资源属性定义确实需要一些特殊的考虑，这与传统关系型数据库有所不同。MongoDB的文档模型和查询能力为我们提供了更灵活的实现方式。

## 🎯 MongoDB中资源属性定义的核心调整

MongoDB的文档模型非常适合存储半结构化的权限策略数据，我们需要充分利用其优势：

### 1. 资源属性定义格式（MongoDB优化版）

在MongoDB中，我建议使用更加**嵌套和灵活**的文档结构：

```json
// MongoDB文档示例 - 资源类型定义
{
  "_id": ObjectId("5f9d1b9b8c7d6e5a3c2b1a0f"),
  "resourceType": "sales:order:Order",
  "description": "销售订单实体",
  "service": "order-service",
  "version": "1.0",
  "attributes": {
    "id": {
      "type": "string",
      "required": true,
      "description": "订单唯一标识",
      "path": "_id"  // MongoDB中的实际字段路径
    },
    "ownerId": {
      "type": "string", 
      "description": "订单负责人",
      "path": "createdBy.userId"
    },
    "department": {
      "type": "string",
      "description": "所属部门",
      "path": "metadata.departmentId"
    },
    "amount": {
      "type": "number",
      "description": "订单金额",
      "path": "payment.amount"
    },
    "status": {
      "type": "enum",
      "values": ["PENDING", "APPROVED", "REJECTED"],
      "description": "订单状态",
      "path": "currentStatus"
    },
    "createdAt": {
      "type": "date",
      "description": "创建时间",
      "path": "timestamps.createdAt"
    }
  },
  "indexes": [
    {"field": "createdBy.userId", "options": {"background": true}},
    {"field": "metadata.departmentId", "options": {"background": true}}
  ],
  "createdAt": ISODate("2023-10-15T08:00:00Z"),
  "updatedAt": ISODate("2023-10-15T08:00:00Z")
}
```

### 2. 权限策略存储格式（MongoDB优化）

```json
// 权限策略文档 - 充分利用MongoDB的嵌套查询能力
{
  "_id": ObjectId("5f9d1b9b8c7d6e5a3c2b1a0e"),
  "name": "department-order-access",
  "description": "部门内订单访问权限",
  "resourceType": "sales:order:Order",
  "effect": "ALLOW",
  "conditions": {
    "operator": "$and",
    "conditions": [
      {
        "attribute": "user.role",
        "operator": "$in",
        "value": ["department-manager", "team-leader"]
      },
      {
        "attribute": "resource.department",
        "operator": "$eq",
        "value": {"$var": "user.departmentId"}
      },
      {
        "attribute": "resource.status",
        "operator": "$ne",
        "value": "ARCHIVED"
      }
    ]
  },
  "priority": 10,
  "enabled": true,
  "createdBy": "admin@example.com",
  "createdAt": ISODate("2023-10-15T08:00:00Z"),
  "updatedAt": ISODate("2023-10-15T08:00:00Z")
}
```

### 3. 权限决策上下文格式

```json
// 权限检查请求 - 优化用于MongoDB查询生成
{
  "principal": {
    "id": "user123",
    "roles": ["department-manager", "data-viewer"],
    "attributes": {
      "departmentId": "dept-001",
      "region": "north-china",
      "clearanceLevel": 5
    }
  },
  "action": "read",
  "resource": {
    "type": "sales:order:Order",
    "id": "order-456", // 可选，特定资源检查时使用
    "attributes": {    // 当前资源的已知属性（可选）
      "department": "dept-001",
      "amount": 2500
    }
  },
  "environment": {
    "time": "2023-10-15T14:30:00+08:00",
    "ip": "192.168.1.100",
    "device": "desktop"
  }
}
```

## 🔧 MongoDB特定优化建议

### 1. 索引策略

```javascript
// 为权限策略集合创建优化索引
db.permission_policies.createIndex({
  "resourceType": 1,
  "enabled": 1,
  "priority": -1
}, {
  "name": "policy_lookup_idx",
  "background": true
});

// 为条件中常用的属性创建索引
db.permission_policies.createIndex({
  "conditions.conditions.attribute": 1,
  "conditions.conditions.value": 1
}, {
  "name": "condition_attr_idx",
  "background": true
});
```

### 2. 查询生成器设计

为MongoDB设计专门的查询条件生成器：

```javascript
// MongoDB查询条件生成器示例
class MongoConditionBuilder {
  
  buildCondition(permissionCondition, context) {
    const mongoConditions = [];
    
    for (const condition of permissionCondition.conditions) {
      const mongoCondition = this.buildSingleCondition(condition, context);
      mongoConditions.push(mongoCondition);
    }
    
    return permissionCondition.operator === '$or' 
      ? {'$or': mongoConditions}
      : {'$and': mongoConditions};
  }
  
  buildSingleCondition(condition, context) {
    const { attribute, operator, value } = condition;
    const resolvedValue = this.resolveValue(value, context);
    
    // 处理MongoDB操作符
    switch (operator) {
      case '$eq':
        return { [this.getFieldPath(attribute)]: resolvedValue };
      case '$ne':
        return { [this.getFieldPath(attribute)]: { '$ne': resolvedValue } };
      case '$in':
        return { [this.getFieldPath(attribute)]: { '$in': resolvedValue } };
      case '$gt':
        return { [this.getFieldPath(attribute)]: { '$gt': resolvedValue } };
      // 更多操作符处理...
      default:
        throw new Error(`Unsupported operator: ${operator}`);
    }
  }
  
  getFieldPath(attribute) {
    // 将抽象属性转换为MongoDB文档路径
    const attributeConfig = this.getAttributeConfig(attribute);
    return attributeConfig.path || attribute;
  }
  
  resolveValue(value, context) {
    // 处理变量引用，如 {"$var": "user.departmentId"}
    if (typeof value === 'object' && value.$var) {
      return this.resolveVariable(value.$var, context);
    }
    return value;
  }
}
```

### 3. 聚合管道优化

对于复杂的数据权限过滤，可以使用MongoDB聚合管道：

```javascript
// 使用聚合管道进行数据权限过滤
const pipeline = [
  // 第一阶段：基础查询
  { $match: { status: 'ACTIVE' } },
  
  // 第二阶段：权限过滤
  { $match: {
    $expr: {
      $and: [
        { $eq: ["$metadata.departmentId", userDepartment] },
        { $lte: ["$payment.amount", userMaxAmount] },
        { $in: ["$currentStatus", ["PENDING", "APPROVED"]] }
      ]
    }
  }},
  
  // 第三阶段：投影和排序
  { $project: { 
    orderId: "$_id",
    amount: "$payment.amount",
    status: 1,
    department: "$metadata.departmentId"
  }},
  { $sort: { createdAt: -1 } }
];
```

## 🚀 MongoDB特定功能利用

### 1. 使用文档验证（Schema Validation）

```javascript
// 为权限策略集合添加模式验证
db.createCollection("permission_policies", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["resourceType", "effect", "conditions"],
      properties: {
        resourceType: {
          bsonType: "string",
          description: "必须为字符串类型"
        },
        effect: {
          enum: ["ALLOW", "DENY"],
          description: "必须为ALLOW或DENY"
        },
        conditions: {
          bsonType: "object",
          required: ["operator"],
          properties: {
            operator: {
              enum: ["$and", "$or"],
              description: "必须为$and或$or"
            }
          }
        }
      }
    }
  }
});
```

### 2. 利用变更流（Change Streams）实现实时更新

```javascript
// 监听权限策略变更
const changeStream = db.permission_policies.watch([
  { $match: { "operationType": { $in: ["insert", "update", "delete"] } } }
]);

changeStream.on('change', (change) => {
  // 通知所有服务节点更新权限缓存
  notificationService.broadcast('PERMISSION_UPDATED', {
    policyId: change.documentKey._id,
    operation: change.operationType
  });
});
```

## 📊 性能优化建议

1. **嵌入式设计**：将常用的权限属性直接嵌入到业务文档中，减少关联查询
2. **预计算字段**：为频繁使用的权限条件添加预计算字段
3. **分片策略**：根据resourceType进行分片，提高大规模数据下的性能
4. **查询分析**：定期使用`db.collection.explain()`分析权限查询性能

## 🎯 总结：MongoDB适配的关键调整

1. **利用嵌套文档**：代替关系型数据库的多表关联
2. **路径映射**：添加`path`字段将抽象属性映射到具体文档路径
3. **MongoDB操作符**：使用`$eq`, `$in`, `$gt`等原生操作符
4. **聚合管道**：利用聚合框架实现复杂权限过滤
5. **变更流**：实现实时的权限策略更新通知

这样的设计既保持了与统一权限协议的一致性，又充分利用了MongoDB的优势，能够提供高性能和灵活的数据权限管理解决方案。

需要我进一步详细说明任何部分吗？
